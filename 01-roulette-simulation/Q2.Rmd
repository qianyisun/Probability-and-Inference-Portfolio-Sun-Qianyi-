---
title: "Q2"
output:
  html_document:
    df_print: paged
---

Q2:Show your audience how changing a parameter of the simulation (see table below) does or does not have an impact on average earnings. A figure would be helpful.

For Q2, we can see that there are four parameters we can change. The four parameters are B, W, L and M. But these parameters are mutual restrains. For example, B is less than W. I set B=b. The value of b is from 201 to 300. we set walk_out_money as y-axis. walk_out_money means that when a gambler stops the game, how much money he or she has. And we set xb as x-axis. The values of xb is from 201 to 300. Then we use plot() to draw a figure. By analyzing the result from first chunk code, we can know that the starting budget(B)  and walk_out_money has positive correlation. At the same time, we can indirectly find that the probability of winning is higher when the starting budget(B) is closer to the budget threshold for successfully stoping(W). In the same way, we change the budget threshold for successfully stoping(W) in the second chunk code. From the figure, we can find that the budget threshold for successfully stoping and walk_out_money has negative correlation. And By changing the maximum number of plays(L) and the casino wager limit(M), we can find that L and M has no distinct correlation.


```{r}

#' A single play of the Martingale strategy
#'
#' Takes a state list, spins the roulette wheel, returns the state list with updated values (for example, budget, plays, etc)
#' @param state A list with the following entries: 
#'   B              number, the starting budget
#'   W              number, the budget threshold for successfully stoping
#'   L              number, the maximum number of plays 
#'   M              number, the casino wager limit
#'   plays          integer, the number of plays executed
#'   previous_wager number, the wager in the previous play (0 at first play)
#'   previous_win   TRUE/FALSE, indicator if the previous play was a win (TRUE at first play)
#' @return The updated state list
library(dplyr)
one_play <- function(state){
  
    # Wager
    proposed_wager <- ifelse(state$previous_win, 1, 2*state$previous_wager)
    wager <- min(proposed_wager, state$M, state$B)
    
    # Spin of the wheel
    red <- rbinom(1,1,18/38)
    
    # Update state
    state$plays <- state$plays + 1
    state$previous_wager <- wager
    if(red){
      # WIN
      state$B <- state$B + wager
      state$previous_win <- TRUE
    }else{
      # LOSE
      state$B <- state$B - wager
      state$previous_win <- FALSE
    }
  state
}


#' Stopping rule
#'
#' Takes the state list and determines if the gambler has to stop
#' @param state A list.  See one_play
#' @return TRUE/FALSE
stop_play <- function(state){
  if(state$B <= 0) return(TRUE)
  if(state$plays >= state$L) return(TRUE)
  if(state$B >= state$W) return(TRUE)
  FALSE
}


#' Play roulette to either bankruptcy, success, or play limits
#'
#' @param B number, the starting budget
#' @param W number, the budget threshold for successfully stoping
#' @param L number, the maximum number of plays 
#' @param M number, the casino wager limit
#' @return A vector of budget values calculated after each play.
one_series <- function(
    B = 200
  , W = 300
  , L = 1000
  , M = 100
){

  # initial state
  state <- list(
    B = B
  , W = W
  , L = L
  , M = M
  , plays = 0
  , previous_wager = 0
  , previous_win = TRUE
  )
  
  # vector to store budget over series of plays
  budget <- rep(NA, L)
  
  # For loop of plays
  for(i in 1:L){
    new_state <- state %>% one_play
    budget[i] <- new_state$B
    if(new_state %>% stop_play){
      return(budget[1:i])
    }
    state <- new_state
  }
  budget    
}

# helper function
get_last <- function(x) x[length(x)] 


# Simulation
store_outmoney <- rep(NA, 100)
for(i in 1:100){
b=i+200 # set a oringinal value of Starting budget

walk_out_money <- rep(NA, 100)#when walking out, person has the money ///if we want to run a plot quickly, we should set with rep()'s time is smaller interger
for(j in seq_along(walk_out_money)){
  walk_out_money[j] <- one_series(B = b, W = 300, L = 1000, M = 100) %>% get_last#get_last is function(x) x[length(x)] 's value of last one

}
store_outmoney[i] <-mean(walk_out_money)#store_outmoney contains all of mean of walk_out_money



# Walk out money distribution
#hist(walk_out_money, breaks = 100)

# Estimated probability of walking out with extra cash
#mean(walk_out_money > 200)

# Estimated earnings
y=mean(walk_out_money - 200)
}
xb<- 201:300 # original budget is from 201 to 300.
plot(x=xb,y=store_outmoney,type="l")#draw a line chart

# when walk_out_money<-rep(NA,X), X is growing. Then the plot will show xb and store_outmoney has positive relation.
```

```{r}
#' A single play of the Martingale strategy
#'
#' Takes a state list, spins the roulette wheel, returns the state list with updated values (for example, budget, plays, etc)
#' @param state A list with the following entries: 
#'   B              number, the starting budget
#'   W              number, the budget threshold for successfully stoping
#'   L              number, the maximum number of plays 
#'   M              number, the casino wager limit
#'   plays          integer, the number of plays executed
#'   previous_wager number, the wager in the previous play (0 at first play)
#'   previous_win   TRUE/FALSE, indicator if the previous play was a win (TRUE at first play)
#' @return The updated state list
library(dplyr)
one_play <- function(state){
  
    # Wager
    proposed_wager <- ifelse(state$previous_win, 1, 2*state$previous_wager)
    wager <- min(proposed_wager, state$M, state$B)
    
    # Spin of the wheel
    red <- rbinom(1,1,18/38)
    
    # Update state
    state$plays <- state$plays + 1
    state$previous_wager <- wager
    if(red){
      # WIN
      state$B <- state$B + wager
      state$previous_win <- TRUE
    }else{
      # LOSE
      state$B <- state$B - wager
      state$previous_win <- FALSE
    }
  state
}


#' Stopping rule
#'
#' Takes the state list and determines if the gambler has to stop
#' @param state A list.  See one_play
#' @return TRUE/FALSE
stop_play <- function(state){
  if(state$B <= 0) return(TRUE)
  if(state$plays >= state$L) return(TRUE)
  if(state$B >= state$W) return(TRUE)
  FALSE
}


#' Play roulette to either bankruptcy, success, or play limits
#'
#' @param B number, the starting budget
#' @param W number, the budget threshold for successfully stoping
#' @param L number, the maximum number of plays 
#' @param M number, the casino wager limit
#' @return A vector of budget values calculated after each play.
one_series <- function(
    B = 200
  , W = 300
  , L = 1000
  , M = 100
){

  # initial state
  state <- list(
    B = B
  , W = W
  , L = L
  , M = M
  , plays = 0
  , previous_wager = 0
  , previous_win = TRUE
  )
  
  # vector to store budget over series of plays
  budget <- rep(NA, L)
  
  # For loop of plays
  for(i in 1:L){
    new_state <- state %>% one_play
    budget[i] <- new_state$B
    if(new_state %>% stop_play){
      return(budget[1:i])
    }
    state <- new_state
  }
  budget    
}

# helper function
get_last <- function(x) x[length(x)] 


# Simulation
store_outmoney <- rep(NA, 100)
for(i in 1:100){
w=i+200 # set a oringinal value of Starting budget

walk_out_money <- rep(NA, 100)#when walking out, person has the money ///if we want to run a plot quickly, we should set with rep()'s time is smaller interger
for(j in seq_along(walk_out_money)){
  walk_out_money[j] <- one_series(B = 200, W = w, L = 1000, M = 100) %>% get_last#get_last is function(x) x[length(x)] 's value of last one

}
store_outmoney[i] <-mean(walk_out_money)#store_outmoney contains all of mean of walk_out_money



# Walk out money distribution
#hist(walk_out_money, breaks = 100)

# Estimated probability of walking out with extra cash
#mean(walk_out_money > 200)

# Estimated earnings
y=mean(walk_out_money - 200)
}
xw<- 201:300 # the budget threshold for successfully stoping is from 201 to 300.
plot(x=xw,y=store_outmoney,type="l")#draw a line chart

# when walk_out_money<-rep(NA,X), X is growing. Then the plot will show xb and store_outmoney has positive relation.
```



```{r}
#' A single play of the Martingale strategy
#'
#' Takes a state list, spins the roulette wheel, returns the state list with updated values (for example, budget, plays, etc)
#' @param state A list with the following entries: 
#'   B              number, the starting budget
#'   W              number, the budget threshold for successfully stoping
#'   L              number, the maximum number of plays 
#'   M              number, the casino wager limit
#'   plays          integer, the number of plays executed
#'   previous_wager number, the wager in the previous play (0 at first play)
#'   previous_win   TRUE/FALSE, indicator if the previous play was a win (TRUE at first play)
#' @return The updated state list
library(dplyr)
one_play <- function(state){
  
    # Wager
    proposed_wager <- ifelse(state$previous_win, 1, 2*state$previous_wager)
    wager <- min(proposed_wager, state$M, state$B)
    
    # Spin of the wheel
    red <- rbinom(1,1,18/38)
    
    # Update state
    state$plays <- state$plays + 1
    state$previous_wager <- wager
    if(red){
      # WIN
      state$B <- state$B + wager
      state$previous_win <- TRUE
    }else{
      # LOSE
      state$B <- state$B - wager
      state$previous_win <- FALSE
    }
  state
}


#' Stopping rule
#'
#' Takes the state list and determines if the gambler has to stop
#' @param state A list.  See one_play
#' @return TRUE/FALSE
stop_play <- function(state){
  if(state$B <= 0) return(TRUE)
  if(state$plays >= state$L) return(TRUE)
  if(state$B >= state$W) return(TRUE)
  FALSE
}


#' Play roulette to either bankruptcy, success, or play limits
#'
#' @param B number, the starting budget
#' @param W number, the budget threshold for successfully stoping
#' @param L number, the maximum number of plays 
#' @param M number, the casino wager limit
#' @return A vector of budget values calculated after each play.
one_series <- function(
    B = 200
  , W = 300
  , L = 1000
  , M = 100
){

  # initial state
  state <- list(
    B = B
  , W = W
  , L = L
  , M = M
  , plays = 0
  , previous_wager = 0
  , previous_win = TRUE
  )
  
  # vector to store budget over series of plays
  budget <- rep(NA, L)
  
  # For loop of plays
  for(i in 1:L){
    new_state <- state %>% one_play
    budget[i] <- new_state$B
    if(new_state %>% stop_play){
      return(budget[1:i])
    }
    state <- new_state
  }
  budget    
}

# helper function
get_last <- function(x) x[length(x)] 


# Simulation
store_outmoney <- rep(NA, 100)
for(i in 1:100){
l=i+900 # set a oringinal value of Starting budget

walk_out_money <- rep(NA, 100)#when walking out, person has the money ///if we want to run a plot quickly, we should set with rep()'s time is smaller interger
for(j in seq_along(walk_out_money)){
  walk_out_money[j] <- one_series(B = 200, W = 300, L = l, M = 100) %>% get_last#get_last is function(x) x[length(x)] 's value of last one

}
store_outmoney[i] <-mean(walk_out_money)#store_outmoney contains all of mean of walk_out_money



# Walk out money distribution
#hist(walk_out_money, breaks = 100)

# Estimated probability of walking out with extra cash
#mean(walk_out_money > 200)

# Estimated earnings
y=mean(walk_out_money - 200)
}
xl<- 901:1000 # the maximum number of plays is from 901 to 1000.
plot(x=xl,y=store_outmoney,type="l")#draw a line chart

# when walk_out_money<-rep(NA,X), X is growing. Then the plot will show xb and store_outmoney has positive relation.
```


```{r}

#' A single play of the Martingale strategy
#'
#' Takes a state list, spins the roulette wheel, returns the state list with updated values (for example, budget, plays, etc)
#' @param state A list with the following entries: 
#'   B              number, the starting budget
#'   W              number, the budget threshold for successfully stoping
#'   L              number, the maximum number of plays 
#'   M              number, the casino wager limit
#'   plays          integer, the number of plays executed
#'   previous_wager number, the wager in the previous play (0 at first play)
#'   previous_win   TRUE/FALSE, indicator if the previous play was a win (TRUE at first play)
#' @return The updated state list
library(dplyr)
one_play <- function(state){
  
    # Wager
    proposed_wager <- ifelse(state$previous_win, 1, 2*state$previous_wager)
    wager <- min(proposed_wager, state$M, state$B)
    
    # Spin of the wheel
    red <- rbinom(1,1,18/38)
    
    # Update state
    state$plays <- state$plays + 1
    state$previous_wager <- wager
    if(red){
      # WIN
      state$B <- state$B + wager
      state$previous_win <- TRUE
    }else{
      # LOSE
      state$B <- state$B - wager
      state$previous_win <- FALSE
    }
  state
}


#' Stopping rule
#'
#' Takes the state list and determines if the gambler has to stop
#' @param state A list.  See one_play
#' @return TRUE/FALSE
stop_play <- function(state){
  if(state$B <= 0) return(TRUE)
  if(state$plays >= state$L) return(TRUE)
  if(state$B >= state$W) return(TRUE)
  FALSE
}


#' Play roulette to either bankruptcy, success, or play limits
#'
#' @param B number, the starting budget
#' @param W number, the budget threshold for successfully stoping
#' @param L number, the maximum number of plays 
#' @param M number, the casino wager limit
#' @return A vector of budget values calculated after each play.
one_series <- function(
    B = 200
  , W = 300
  , L = 1000
  , M = 100
){

  # initial state
  state <- list(
    B = B
  , W = W
  , L = L
  , M = M
  , plays = 0
  , previous_wager = 0
  , previous_win = TRUE
  )
  
  # vector to store budget over series of plays
  budget <- rep(NA, L)
  
  # For loop of plays
  for(i in 1:L){
    new_state <- state %>% one_play
    budget[i] <- new_state$B
    if(new_state %>% stop_play){
      return(budget[1:i])
    }
    state <- new_state
  }
  budget    
}

# helper function
get_last <- function(x) x[length(x)] 


# Simulation
store_outmoney <- rep(NA, 100)
for(i in 1:100){
m=i+50 # set a oringinal value of Starting budget

walk_out_money <- rep(NA, 100)#when walking out, person has the money ///if we want to run a plot quickly, we should set with rep()'s time is smaller interger
for(j in seq_along(walk_out_money)){
  walk_out_money[j] <- one_series(B = 200, W = 300, L = 1000, M = m) %>% get_last#get_last is function(x) x[length(x)] 's value of last one

}
store_outmoney[i] <-mean(walk_out_money)#store_outmoney contains all of mean of walk_out_money



# Walk out money distribution
#hist(walk_out_money, breaks = 100)

# Estimated probability of walking out with extra cash
#mean(walk_out_money > 200)

# Estimated earnings
y=mean(walk_out_money - 200)
}
xm<- 51:150 # number, the casino wager limit is from 51 to 150.
plot(x=xm,y=store_outmoney,type="l")#draw a line chart

# when walk_out_money<-rep(NA,X), X is growing. Then the plot will show xb and store_outmoney has positive relation.
```


